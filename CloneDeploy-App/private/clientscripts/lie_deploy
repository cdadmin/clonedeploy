#!/bin/bash

. /bin/lie_global_functions

if [ "$started_from_init" != "true" ]; then
	error "Script Cannot Be Started This Way, Exports Are Not Set."
fi

function process_hard_drives()
{
  local drive_name
  local lbs
  local drive_size_block
  
  get_hard_drives "deploy"

  imaged_schema_drives=""
  current_hd_number=-1
  for hard_drive in $hard_drives; do
    echo
    log " ** Processing $hard_drive ** " "display"
    current_hd_number=$(( $current_hd_number + 1 ))
	
	if [ -n "$pre_scripts" ]; then
	  process_scripts "$pre_scripts"
	fi
	
    drive_name=$(echo $hard_drive | cut -d "/" -f 3)
    lbs=$(cat /sys/block/$drive_name/queue/logical_block_size)
	drive_size_block=$(blockdev --getsz $hard_drive) #Always outputs for 512 byte sectors, needs changed for other sector sizes
    if [ "$lbs" = "4096" ]; then
	  drive_size_block=$(( $drive_size_block / 8 ))
	fi
 
    drive_size_bytes=$(expr $lbs '*' $drive_size_block)
	
    log "Get hd_schema:  profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$drive_size_bytes&schemaHds=$imaged_schema_drives&clientLbs=$lbs"
    hd_schema=$($curlAuth --data "profileId=$profile_id&clientHdNumber=$current_hd_number&newHdSize=$drive_size_bytes&schemaHds=$(remove_whitespace $imaged_schema_drives)&clientLbs=$lbs" "${web}CheckHdRequirements" $curlEnd)
    log "$hd_schema"
	
    image_hd_to_use=$(parse_json "$hd_schema" .SchemaHdNumber)
    image_path=/storage/images/$image_name/hd$image_hd_to_use
	
    create_partition_layout
	
    process_partitions
	
	make_bootable
	
	update_efi_nvram
    
	imaged_schema_drives="$imaged_schema_drives $(parse_json "$hd_schema" .SchemaHdNumber) "
	
	if [ -n "$post_scripts" ]; then
	  process_scripts "$post_scripts"
	fi
done
}


function process_lvm()
{
  local array_index=-1
  local volume_group="$(parse_json "$current_partition" .VolumeGroup.Name)"
  local make_swap_result
  local current_logical_volume
  local escaped_lv_name
  
   volume_group=$(echo $volume_group | sed 's/-/--/g')
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$current_partition" .VolumeGroup.LogicalVolumeCount)" ]; do
    array_index=$(( $array_index + 1))
    clear_and_move_down
    current_logical_volume="$(parse_json "$current_partition" .VolumeGroup.LogicalVolumes[$array_index])"
	log "$current_logical_volume"
    escaped_lv_name=$(echo $(parse_json "$current_logical_volume" .Name) | sed 's/-/--/g')
	
	if [ "$(parse_json "$current_logical_volume" .FileSystem)" = "swap" ]; then
      log "Creating Swap On $volume_group-$escaped_lv_name"
      log "$(parse_json "$current_logical_volume" .Uuid)"
	  swap_uuid=$(echo $(parse_json "$current_logical_volume" .Uuid) | cut -d# -f2)
      mkswap /dev/mapper/$volume_group-$escaped_lv_name -U $swap_uuid &>> /tmp/makeswap
      cat /tmp/makeswap >>$CLIENT_LOG
      make_swap_result=$(cat /tmp/makeswap | grep "parsing UUID failed")
      if [ "$?" = "0" ]; then
        log " ...... Swap Creation Failed, Creating Swap With New UUID "
        mkswap /dev/mapper/$volume_group-$escaped_lv_name &>> $CLIENT_LOG
      fi
      continue
    fi
				
    download_image "$current_logical_volume" "$volume_group-$escaped_lv_name"
	
	if [ "$skip_expand_volumes" != "true" ]; then 
      if [ "$(parse_json "$current_logical_volume" .ImageType)" = "Block" ]; then
        expand_volume /dev/mapper/$volume_group-$escaped_lv_name $(parse_json "$current_logical_volume" .FileSystem)  
      fi
    fi
	
	if [ "$file_copy" = "True" ]; then
	  process_file_copy "$current_logical_volume" "$volume_group-$escaped_lv_name"
	fi
    clear_and_move_down
  done
}

function process_partitions()
{
  local partition_size_mb
  local array_index=-1
  
  if [ "$file_copy" = "True" ]; then
    log "file_copy_schema: profileId=$profile_id"
	 file_copy_schema=$($curlAuth --data "profileId=$profile_id" "${web}GetFileCopySchema" $curlEnd)
	 log "File Copy Schema: $file_copy_schema"
  fi
	
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
    array_index=$(( $array_index + 1))
    clear_and_move_down
    current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
    log "$current_partition"
	
    if [ -n "$(parse_json "$current_partition" .VolumeGroup)" ] && [ "$(parse_json "$current_partition" .VolumeGroup)" != "null" ]; then
      process_lvm
      continue
    fi
	
	#Only restore extended partition if the hd is the same size as the original
	if [ "$(parse_json "$current_partition" .Type)" = "extended" ]; then
	  if [ "$(parse_json "$hd_schema" .IsValid)" != "original" ] || [ "$force_dynamic_partitions" = "true" ]; then
	    continue
      fi
	fi
	
	get_partitions_according_to_mbr_gpt
	for partition in $mbr_gpt_partitions; do
	  partition_prefix=$(echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g')
	done
	
	if [ "$standard_partition_type" = "legacy" ]; then
	  this_partition=${hard_drive}${partition_prefix}2
	  this_number=2
	elif [ "$standard_partition_type" = "efi" ]; then
	  this_partition=${hard_drive}${partition_prefix}4
	  this_number=4
	else
      this_partition=${hard_drive}${partition_prefix}$(parse_json "$current_partition" .Number)
      this_number=$(parse_json "$current_partition" .Number)
	fi
	
	
    if [ "$(parse_json "$current_partition" .FileSystem)" = "swap" ]; then
      log "Creating Swap On $hard_drive${partition_prefix}$(parse_json "$current_partition" .Number)"
      log "$(parse_json "$current_partition" .Uuid)"
      mkswap ${hard_drive}${partition_prefix}$(parse_json "$current_partition" .Number) -U $(parse_json "$current_partition" .Uuid) &>> $CLIENT_LOG	
      continue
    fi
			
    download_image "$current_partition" part
		
	partition_size_bytes=$(parted -s $hard_drive unit b print all | grep " $this_number " -m 1 | awk -F' ' '{print $4}' | sed 's/B//g')

    if [ "$skip_expand_volumes" != "true" ]; then 
      if [ "$(parse_json "$current_partition" .ImageType)" = "Block" ] && [ "$partition_size_bytes" -gt "5368709120" ]; then #partition smaller than 5GB probably that way for a reason, leave it alone.
        expand_volume $this_partition $(parse_json "$current_partition" .FileSystem)  
      fi
    fi
	
	if [ "$partition_method" != "standard" ]; then
      if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
        log " ** Restoring GUID On ${hard_drive}$(parse_json "$current_partition" .Number) ** "
        log " ...... part $part gptGUID: $(parse_json "$current_partition" .Guid) "
        sgdisk $hard_drive -u$(parse_json "$current_partition" .Number):$(parse_json "$current_partition" .Guid) &>> $CLIENT_LOG
      fi
	fi
	
	if [ "$partition_method" != "standard" ]; then
      if [ "$(parse_json "$hd_schema" .BootPartition)" = "$(parse_json "$current_partition" .Number)" ] && [ "$(parse_json "$current_partition" .FileSystem)" = "ntfs" ]; then
        fix_ntfs_boot ${hard_drive}${partition_prefix}$(parse_json "$current_partition" .Number)
      fi
	fi
	
	#Todo: Add support for linux change name
	if [ "$(parse_json "$current_partition" .FileSystem)" = "ntfs" ] && [ -n "$computer_name" ] && [ "$change_computer_name" = "true" ]; then
      change_computer_name $this_partition
	fi
	
	if [ "$(parse_json "$current_partition" .FileSystem)" = "ntfs" ] && [ -n "$sysprep_tags" ]; then
      process_sysprep_tags  $this_partition
	fi
	
	if [ "$(parse_json "$current_partition" .FileSystem)" = "hfsplus" ]; then
	  log " ** Repairing Hfsplus filesystem" "display"
      fsck.hfsplus -f ${hard_drive}${partition_prefix}$(parse_json "$current_partition" .Number)
	  sleep 5
	fi
	
	if [ "$file_copy" = "True" ]; then
	  process_file_copy "$current_partition" "partition"
	fi
  done
}

function download_image()
{
  local current_object="$1"
  local file_name_prefix="$2"
  local destination
    
  if [ "$file_name_prefix" != "part" ]; then
    destination="/dev/mapper/$file_name_prefix"
	file_name_prefix=$(echo $file_name_prefix | sed 's/--/-/g')
  else
    if [ "$standard_partition_type" = "legacy" ]; then
	  destination=${hard_drive}${partition_prefix}2
	elif [ "$standard_partition_type" = "efi" ]; then
	  destination=${hard_drive}${partition_prefix}4
	else
      destination=${hard_drive}${partition_prefix}$(parse_json "$current_object" .Number)
     
	fi
	 file_name_prefix=part"$(parse_json "$current_object" .Number)"
  fi
  
  log " ** Starting Image Download For $destination ** " "display" 

  $curlAuth --data "taskId=$task_id&partition=$destination" "${web}UpdateProgressPartition" $curlEnd
  
  sleep 7
  echo
	
  if [ "$(parse_json "$current_object" .ImageType)" = "Block" ]; then
    if [ "$(parse_json "$current_object" .Compression)" = "gz" ]; then
      partCompAlg="gzip -c -d"
      partCompExt="gz"
    elif [ "$(parse_json "$current_object" .Compression)" = "lz4" ]; then
      partCompAlg="lz4 -d"
      partCompExt="lz4"
    elif [ "$(parse_json "$current_object" .Compression)" = "uncp" ]; then
      partCompAlg="none"
      partCompExt=""
    else
      error "Could Not Determine Compression Algorithm For Partition"
    fi
  		
  touch /tmp/clone.progress
			
  if [ "$task" = "multicast" ] || [ "$task" = "ondmulticast" ]; then
    if [ "$decompress_multicast_on_client" = "true" ]; then
	    log "lie_reporter $task_id partclone & udp-receiver --portbase $multicast_port --no-progress $client_receiver_args | $partCompAlg | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination"
      lie_reporter $task_id partclone & udp-receiver --portbase $multicast_port --no-progress $client_receiver_args | $partCompAlg | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination
	else #dcompress on server
      log "lie_reporter $task_id partclone & udp-receiver --portbase $multicast_port --no-progress $client_receiver_args | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination"
      lie_reporter $task_id partclone & udp-receiver --portbase $multicast_port --no-progress $client_receiver_args | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination
    fi
  else #unicast
    if [ "$partCompAlg" = "none" ]; then #no compression
	   lie_reporter $task_id partclone & partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -s $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).uncp -o $destination
	   log "lie_reporter $task_id partclone & partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -s $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).uncp -o $destination"
	else #compression in use
      log "lie_reporter $task_id partclone & $partCompAlg $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).$partCompExt | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination"
      lie_reporter $task_id partclone & $partCompAlg $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).$partCompExt | partclone.$(parse_json "$current_object" .PartcloneFileSystem) -B -r -o $destination
	fi
  fi
			
  rm /tmp/clone.progress
  cat /var/log/partclone.log >> $CLIENT_LOG
  else # ImageType = File
    export WIMLIB_IMAGEX_USE_UTF8=1
    log " ** Creating $(parse_json "$current_object" .FileSystem) Filesystem On $destination ** "
    if [ "$(parse_json "$current_object" .FileSystem)" = "ntfs" ]; then
	  log "mkfs.$(parse_json "$current_object" .FileSystem) -f $destination"
	  mkfs.$(parse_json "$current_object" .FileSystem) -f $destination &>> $CLIENT_LOG
	  ms-sys -n -f $destination	2>> $CLIENT_LOG
	elif [ "$(parse_json "$current_object" .FileSystem)" = "vfat" ]; then
	  log "mkfs.$(parse_json "$current_object" .FileSystem) -f $destination"
	  mkfs.fat -F 32 $destination 2>> $CLIENT_LOG
	elif [ "$(parse_json "$current_object" .FileSystem)" = "xfs" ]; then
	  log "mkfs.$(parse_json "$current_object" .FileSystem) -f $destination"
	  wim_arguments=" --unix-data"
	  mkfs.$(parse_json "$current_object" .FileSystem) -f $destination &>> $CLIENT_LOG
	  xfs_admin -U $(parse_json "$current_object" .Uuid) $destination &>> $CLIENT_LOG
	else #ext filesystems
	  log "mkfs.$(parse_json "$current_object" .FileSystem) -F $destination"
	  wim_arguments=" --unix-data"
	  mkfs.$(parse_json "$current_object" .FileSystem) -F $destination &>> $CLIENT_LOG
	  tune2fs $destination -U $(parse_json "$current_object" .Uuid) &>> $CLIENT_LOG
	fi
	
	
	if [ "$(parse_json "$current_object" .FileSystem)" != "ntfs" ]; then
	  mkdir /mnt/fs &> /dev/null
	  umount /mnt/fs &> /dev/null
	  mount $destination /mnt/fs 2>> $CLIENT_LOG
	  destination="/mnt/fs"
	fi
	
	if [ "$task" = "multicast" ] || [ "$task" = "ondmulticast" ]; then
	  log "lie_reporter $task_id wim & udp-receiver --portbase $multicast_port --no-progress $client_receiver_args | wimlib-imagex apply - 1 $destination $wim_arguments"
	  lie_reporter $task_id wim & udp-receiver --portbase $multicast_port --no-progress $client_receiver_args | wimlib-imagex apply - 1 $destination $wim_arguments 2>> $CLIENT_LOG | tee /tmp/wim.progress
	else
	  log "lie_reporter $task_id wim & wimlib-imagex apply $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).wim 1 $destination $wim_arguments"
	  lie_reporter $task_id wim & wimlib-imagex apply $image_path/$file_name_prefix.$(parse_json "$current_object" .PartcloneFileSystem).wim 1 $destination $wim_arguments 2>> $CLIENT_LOG | tee /tmp/wim.progress
	fi
  fi 
}

function restore_mbr_gpt()
{
  local gpt_status
  local hybrid_status
  
  log " ** Restoring MBR / GPT On $hard_drive ** " "display"
  dd if=$image_path/table of=$hard_drive &>>$CLIENT_LOG				
		
  #Sometimes restoring results in damaged GPT.  Done the long way to hide error messages.
  gdisk -l $hard_drive <<< "2" &>/tmp/gptstatus
  cat /tmp/gptstatus >> $CLIENT_LOG
  gpt_status=$(cat /tmp/gptstatus | grep 'GPT:' | awk '{$1=""; print $0}' | sed 's/^ //')
  if [ "$gpt_status" = "damaged" ]; then
    log "Repairing Damaged GPT Table"
    gdisk $hard_drive << eof &>/dev/null
2
w
y
eof
  fi
	
  hybrid_status=$(gdisk -l $hard_drive <<< "q" 2>> $CLIENT_LOG| grep 'MBR:' | awk '{$1=""; print $0}' | sed 's/^ //')
  if [ "$hybrid_status" = "hybrid" ]; then
    gpt_is_hybrid="true"
  fi
	
  log " ...... Complete" "display"
  echo 
  partprobe &>/dev/null
  sleep 2
}

function create_partition_layout()
{
  local layout_created_successfully
  local layout_failed_counter
  local gpt_partition_count
  local mbr_partition_count
  local preexisting_volume_groups
  local preexisting_physical_volumes
  local new_volume_groups
  local new_logical_volumes
  local volume_group_uuid
  local logical_volume_uuid
  
  if [ "$(parse_json "$hd_schema" .IsValid)" = "true" ]; then
    log " ...... HD Meets The Minimum Sized Required"		
  elif [ "$(parse_json "$hd_schema" .IsValid)" = "false" ]; then
    log " ...... $(parse_json "$hd_schema" .Message)" "display"
    sleep 10
    continue		
  elif [ "$(parse_json "$hd_schema" .IsValid)" = "original" ]; then
    log " ...... HD Matches Original Size Of Image"
  else
    error "Unknown Error Occurred While Determining Minimum HD Size Required.  Check The Exception Log"
  fi
	
  erase_mbr_gpt
  
  
  if [ "$partition_method" != "standard" ]; then 
    restore_mbr_gpt	
    get_partitions_according_to_mbr_gpt
    partition_counter=0
	  for partition in $mbr_gpt_partitions; do
        partition_counter=$(( $partition_counter + 1 ))
        partition_number=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[^0-9]//g'`
        partition_prefix=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g'`
	    break
	  done
  fi

  if [ "$partition_method" = "standard" ]; then
    log "Checking For Type Of Standard Partition To Create"
	if [ "$force_legacy_layout" = "true" ]; then
	  log "Legacy Partition Layout Forced"
	  standard_partition_type="legacy"
	elif [ "$force_efi_layout" = "true" ]; then
	  log "Efi Partition Layout Forced"
	  standard_partition_type="efi"
	else
      mount -t efivarfs none /sys/firmware/efi/efivars &>>$CLIENT_LOG
	  efibootmgr -v &>> $CLIENT_LOG
      if [ "$?" != "0" ]; then
        log "Legacy Partition Layout Selected"
	    standard_partition_type="legacy"
	  else
	    standard_partition_type="efi"
      fi
	fi
	if [ "$standard_partition_type" = "legacy" ]; then
	  parted -s $hard_drive -- mklabel msdos mkpart primary ntfs 2048s 1026047s mkpart primary ntfs 1026048s -2049s set 1 boot on
	else #efi
	  if [ "$lbs" = "512" ]; then #512 or advanced or format, only efi support 4k native no need to check for legacy
	    parted -s $hard_drive -- mklabel gpt mkpart ntfs 2048s 923647s mkpart fat32 923648s 1126399s mkpart fat32 1126400s 1159167s mkpart ntfs 1159168s -2049s set 1 hidden on set 1 diag on set 2 boot on set 3 msftres on
	  else #4k native
	    parted -s $hard_drive -- mklabel gpt mkpart ntfs 256s 115455s mkpart fat32 115456s 182015s mkpart fat32 182016s 186111s mkpart ntfs 186112s -257s set 1 hidden on set 1 diag on set 2 boot on set 3 msftres on
	  fi
	  #not sure why this is needed, fdisk gdisk and parted don't seem to agree on partition type, but only on gpt disks
	  sfdisk --part-type $hard_drive 1 14 &>>$CLIENT_LOG
	  sfdisk --part-type $hard_drive 2 1 &>>$CLIENT_LOG
	  sfdisk --part-type $hard_drive 3 10 &>>$CLIENT_LOG
	  sfdisk --part-type $hard_drive 4 11 &>>$CLIENT_LOG
	  
	fi
  elif [ "$partition_method" = "script" ]; then # create partitions from image profile script
     log " ** Creating Partition Table On $hard_drive From Custom Script ** " "display"
    $curlAuth --data "profileId=$profile_id" "${web}GetCustomPartitionScript" $curlEnd | dos2unix > /tmp/newPartLayout
	cat /tmp/newPartLayout >> $CLIENT_LOG
    bash /tmp/newPartLayout
    partprobe &>/dev/null
  elif [ "$partition_method" = "original" ]; then # create partitions from original mbr / gpt
     log " ** Creating Partition Table On $hard_drive From Original MBR / GPT ** " "display"
	 partprobe &>/dev/null
  elif [ "$(parse_json "$hd_schema" .IsValid)" = "true" ] || [ "$force_dynamic_partitions" = "true" ]; then # create partitions dynamically from image profile settings
    log " ** Creating Partition Table On $hard_drive ** " "display"
    $curlAuth --data "imageProfileId=$profile_id&hdToGet=$image_hd_to_use&newHDSize=$drive_size_bytes&clientHD=$hard_drive&taskType=deploy&partitionPrefix=$partition_prefix&lbs=$lbs" "${web}GetPartLayout" $curlEnd | dos2unix > /tmp/newPartLayout
	if [ "$(cat /tmp/newPartLayout)" = "failed" ]; then
	  error "Could Not Dynamically Create Partition Layout"
	fi
		
    layout_failed_counter=0
    if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
      while [ "$layout_created_successfully" != "true" ]; do		
        delete_all_partitions $hard_drive
		log " ** Partition Creation Script ** "
        cat /tmp/newPartLayout >> $CLIENT_LOG
        bash /tmp/newPartLayout
        partprobe &>/dev/null
        gpt_partition_count=$(gdisk -l $hard_drive 2> /dev/null| awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm -c)
        if [ "$gpt_partition_count" = "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; then
          layout_created_successfully="true"
          log " ...... Success" "display"
        else
          layout_failed_counter=$(( $layout_failed_counter + 1 ))
          log " ...... Could Not Create Partition Layout.  Retrying Attempt $layout_failed_counter"
          if [ "$layout_failed_counter" -gt "10" ]; then
            error "Could Not Create Partition Layout"
          fi
        fi
      done
    else #partitiontype is mbr
      delete_all_partitions $hard_drive
	  log " ** Partition Creation Script ** "
      cat /tmp/newPartLayout >> $CLIENT_LOG
      bash /tmp/newPartLayout
      partprobe &>/dev/null
      mbr_partition_count=$(fdisk -l 2>/dev/null | grep $hard_drive | grep -v ${hard_drive}: -c)
      if [ "$mbr_partition_count" != "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; then
        error "Could Not Create Partition Layout"
      fi
    fi
  fi #if neither conditions matched above, partitions were created when the mbr /gpt was restored.
	
  log " ** New Partition Table Is ** "
  if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
    gdisk -l $hard_drive &>>$CLIENT_LOG
  else
    fdisk -l &>>$CLIENT_LOG
  fi
	
  if [ "$gpt_is_hybrid" = "true" ]; then
    create_hybrid_gpt
  fi
	
  if [ "$(parse_json "$hd_schema" .UsesLvm)" = "true" ]; then
    if [ "$(parse_json "$hd_schema" .IsValid)" = "original" ] && [ "$force_dynamic_partitions" != "true" ]; then
      log "Creating Original LVM"
      $curlAuth --data "profileId=$profile_id&clientHd=$hard_drive&hdToGet=$image_hd_to_use&partitionPrefix=$partition_prefix" "${web}GetOriginalLvm" $curlEnd | dos2unix > /tmp/lvmcommands
      cat /tmp/lvmcommands >> $CLIENT_LOG
    fi
	
    if [ -s "/tmp/lvmcommands" ]; then
      dmsetup remove_all
      preexisting_volume_groups=$(vgs --noheadings | awk '/^ / {print $1}')
      for vg in $preexisting_volume_groups; do
        vgremove $vg -fy
      done
	
      preexisting_physical_volumes=$(pvs --noheadings | grep $hard_drive | awk '/^ / {print $1}')
      for pv in $preexisting_physical_volumes; do
        pvremove $pv -fy
      done
	
      bash /tmp/lvmcommands &>>$CLIENT_LOG
      vgscan
		
      new_volume_groups=$(vgs --noheadings | awk '/^ / {print $1}')
      for vg in $new_volume_groups; do
        new_logical_volumes=$(lvs | grep -w "$vg" | awk '/^ / {print $1}')
        volume_group_uuid=$(vgs -v  2>/dev/null | grep -w "$vg" | awk '/^ / {print $9}')
        sed -i "s/$volume_group_uuid/$(cat /tmp/vg-$vg)/g" /tmp/lvm-$vg 
        for logical_volume in $new_logical_volumes; do		
          logical_volume_uuid=$(lvs -v 2>/dev/null | grep -w "$vg" | grep -w "$logical_volume" | awk '/^ / {print $10}')
          sed -i "s/$logical_volume_uuid/$(cat /tmp/$vg-$logical_volume)/g" /tmp/lvm-$vg 
        done
        vgcfgrestore $vg -qy -f /tmp/lvm-$vg
      done			
    else
      return 0
    fi
  fi
  
  if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
	if [ "$partition_method" != "standard" ]; then
	  log " ** Restoring GUID On $hard_drive ** "
	  sgdisk $hard_drive -U$(parse_json "$hd_schema" .Guid) &>> $CLIENT_LOG
	  log "$(parse_json "$hd_schema" .Guid)"
	fi
  fi
}

function create_hybrid_gpt()
{
  #Fix Me. Very generic way of creating hybrid.  May not work in many situations.
  gdisk $hard_drive << eof >> $CLIENT_LOG
r
h
2 3 4 5 6 7 8 9 10
y

n

n

n

n

w
y
eof

  fdisk $hard_drive << eof >> $CLIENT_LOG
x
M
r
a
$(parse_json "$hd_schema" .BootPartition)
w
q
eof
}

function get_partitions_according_to_mbr_gpt()
{
  mbr_gpt_partitions=""
  mbr_gpt_partitions=$(lsblk -ipno KNAME | grep "$hard_drive" | grep -vw "$hard_drive" | grep -v "boot" | grep -v "rpmb" 2>> $CLIENT_LOG)  
}

function update_efi_nvram()
{
  if [ "$skip_nvram" = "true" ]; then
    log "NVRAM update skipped via image profile"
    return 0
  fi
  
  log "Checking if NVRAM needs updated"
  gdisk -l $hard_drive | grep EF00
  if [ "$?" != "0" ]; then
    log "No EFI System Partition Found."
	gdisk -l $hard_drive >> $CLIENT_LOG
	return 1;
  fi
  
  mount -t efivarfs none /sys/firmware/efi/efivars &>>$CLIENT_LOG
  
  log "Existing NVRAM"
  efibootmgr -v &>> $CLIENT_LOG
  if [ "$?" != "0" ]; then
    log "EFI Variables Are Not Available"
	return 1
  fi
  
  boot_current=$(efibootmgr -v | awk '$1 == "BootCurrent:" {print $2}')
  original_boot_order=$(efibootmgr -v | awk '$1 == "BootOrder:" {print $2}')
  current_first_boot=$(echo $original_boot_order | cut -d, -f1)

  log "Current Boot: $boot_current First Boot: $current_first_boot"
 
  local array_index=-1
  while [  "$(( $array_index + 1 ))" -lt "$(parse_json "$hd_schema" .PhysicalPartitionCount)" ]; do
    array_index=$(( $array_index + 1))
    clear_and_move_down
    current_partition="$(parse_json "$hd_schema" .PhysicalPartitions[$array_index])"
	existing_bootloader=$(efibootmgr -v | grep -i "$(parse_json "$current_partition" .Guid)" -m1 | grep -o "File(.*)" | cut -d "(" -f2 | cut -d ")" -f1 | uniq)
	boot_number=$(efibootmgr -v | grep -i "$(parse_json "$current_partition" .Guid)" -m1 | cut -d "*" -f1 | sed 's/Boot//g')
	log "$(parse_json "$current_partition" .Number) $existing_bootloader $boot_number"
	partition_bootloader="$(echo "$(parse_json "$current_partition" .EfiBootLoader)" | cut -d# -f2)"
	log "partition_bootloader: $partition_bootloader"
	
	if [ "$partition_method" = "standard" ]; then
	  #Remove any existing Windows Boot Loaders
	  boot_entries_to_delete=$(efibootmgr | grep "Windows Boot Manager" | cut -d "*" -f1 | sed 's/Boot//g')
	  for efi_boot in $boot_entries_to_delete; do
        efibootmgr -B -b $efi_boot 2>>$CLIENT_LOG
      done
	  #Add Standard nvram entry
	   efibootmgr -c -d $hard_drive -p 2 -L "Windows Boot Manager" -l "\\EFI\\Microsoft\\Boot\\bootmgfw.efi" 2>>$CLIENT_LOG
	    if [ "$current_first_boot" = "$boot_current" ]; then
           log "Current Boot and First Boot Match.  Setting boot order back to original."
		   new_boot_order=$(efibootmgr -v | awk '$1 == "BootOrder:" {print $2}')
		   #if current boot and boot current match, we can assume that it must be pxe,usb,or cd boot first or we wouldn't be here.  Assume user wants this to stay first.
		   efibootmgr -o $(move_to_front_of_list $boot_current , $new_boot_order) 2>>$CLIENT_LOG
         else
		   #assume this is a one time pxe,usb, or cd boot.  Let the new entry move to first boot.  Again this may not be what user wants, may need to add option in webui to select
		   log "Current Boot and First Boot Do Not Match.  This bootloader has been moved to the first position."
		 fi
	elif [ -n "$existing_bootloader" ] && [ "$existing_bootloader" = "$partition_bootloader" ]; then
	  log "NVRAM Entry Already Exists.  No changes made."
	  #This partition already has a matching entry in the nvram
	elif [ -n "$existing_bootloader" ]; then
	  log "Updating NVRAM Entry"
	  #Partition has entry in nvram but bootloader doesn't match
	  #Remove it and recreate with proper bootloader
	  efibootmgr -B -b $boot_number 2>>$CLIENT_LOG
	  efibootmgr -c -d $hard_drive -p "$(parse_json "$current_partition" .Number)" -L "$(echo "$(parse_json "$current_partition" .EfiBootLoader)" | cut -d# -f1)"  -l "$(echo "$(parse_json "$current_partition" .EfiBootLoader)" | cut -d# -f2)" 2>>$CLIENT_LOG
	  #efibootmgr -c automatically sets new entry to front of boot order, efibootmgr -C would prevent this, but this seems to work
	  #this should leave the boot order exactly as it was when booted, but this may not be what the user wants, especially if the computer was unbootable to begin with
	  #might need to add option in WebUI to let the user select first boot device
	  
	  #find newly created boot number
	  updated_boot_order=$(efibootmgr -v | awk '$1 == "BootOrder:" {print $2}')
	  new_first_boot=$(echo $updated_boot_order | cut -d, -f1)
	  new_boot_order=$(echo $original_boot_order | sed 's/'$boot_number'/'$new_first_boot'/g' )
	  log "New Boot Order: $new_boot_order"
	  efibootmgr -o $new_boot_order 2>>$CLIENT_LOG
	else
	  #Partition Does not exist in the nvram
	  #Check if it should
	  if [ -n "$(parse_json "$current_partition" .EfiBootLoader)" ] && [ "$(parse_json "$current_partition" .EfiBootLoader)" != "null" ]; then
	    log "Creating New NVRAM Entry"
		
		#Remove any existing Windows Boot Loaders
	    boot_entries_to_delete=$(efibootmgr | grep "Windows Boot Manager" | cut -d "*" -f1 | sed 's/Boot//g')
	    for efi_boot in $boot_entries_to_delete; do
          efibootmgr -B -b $efi_boot 2>>$CLIENT_LOG
        done
		
		#Entry needs added
		#efibootmgr -c automatically sets new entry to front of boot order, efibootmgr -C would prevent this, but this seems to work
	    efibootmgr -c -d $hard_drive -p "$(parse_json "$current_partition" .Number)" -L "$(echo "$(parse_json "$current_partition" .EfiBootLoader)" | cut -d# -f1)" -l "$(echo "$(parse_json "$current_partition" .EfiBootLoader)" | cut -d# -f2)" 2>>$CLIENT_LOG
		
		 if [ "$current_first_boot" = "$boot_current" ]; then
           log "Current Boot and First Boot Match.  Setting boot order back to original."
		   new_boot_order=$(efibootmgr -v | awk '$1 == "BootOrder:" {print $2}')
		   #if current boot and boot current match, we can assume that it must be pxe,usb,or cd boot first or we wouldn't be here.  Assume user wants this to stay first.
		   efibootmgr -o $(move_to_front_of_list $boot_current , $new_boot_order) 2>>$CLIENT_LOG
         else
		   #assume this is a one time pxe,usb, or cd boot.  Let the new entry move to first boot.  Again this may not be what user wants, may need to add option in webui to select
		   log "Current Boot and First Boot Do Not Match.  This bootloader has been moved to the first position."
		 fi
	  fi
	fi
  done
  
  log "Updated NVRAM"
  efibootmgr -v &>> $CLIENT_LOG
  
}

function fix_ntfs_boot()
{
  if [ "$fix_bootloader" != "true" ]; then
    log "Bootloader fix Has Been Skipped Via Image Profile"
    return 0
  fi
  local partition="$1"
  log " ** Fixing NTFS Boot sector ** " "display"
  partclone.ntfsfixboot -p $partition >> $CLIENT_LOG
  partclone.ntfsfixboot -w $partition >> $CLIENT_LOG
		
}

function erase_mbr_gpt()
{
  log " ** Clearing MBR / GPT ** "
  sgdisk -Z $hard_drive &>>$CLIENT_LOG
  dd if=/dev/zero of=$hard_drive bs=512 count=2047 &>>$CLIENT_LOG
  partprobe &> /dev/null
}

function delete_all_partitions()
{
  local partition_count
  local delete_counter
  #Delete all partitions but keep boot record intact
  log " ** Deleting Existing Partitions ** "
  if [ "$(parse_json "$hd_schema" .PartitionType)" = "gpt" ]; then
    partition_count=$(gdisk -l $1 2> /dev/null| awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm -c)
    delete_counter=0
    while [ "$partition_count" -gt "0" ]; do
      delete_counter=$(( $delete_counter + 1 ))
      echo "gdisk $1 &>/dev/null <<GDISK" > /tmp/partition_delete
      for part_num in $(gdisk -l $1 2> /dev/null | awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm); do			
        echo d >> /tmp/partition_delete
        echo "$part_num" >> /tmp/partition_delete
      done
			
      echo w >> /tmp/partition_delete
      echo y >> /tmp/partition_delete
      echo y >> /tmp/partition_delete
      echo q >> /tmp/partition_delete
      echo GDISK >> /tmp/partition_delete
      cat /tmp/partition_delete >> $CLIENT_LOG
      bash /tmp/partition_delete
			
      gdisk $1 &>/dev/null <<GDISK
d
$part_num
w
y
y
q
GDISK
			
      partition_count=$(gdisk -l $1 2> /dev/null | awk '/^ / {print $1}' | grep -vi mbr | grep -vi gpt | grep -vi bsd | grep -vi apm -c)
      if [ "$delete_counter" -gt "1000" ]; then
        log " ...... Partitions Still Exist"
        gdisk -l $1 &>>$CLIENT_LOG
        error "Could Not Delete GPT Partitions"
      fi
    done		
  else #mbr
    partition_count=$(fdisk -l 2>/dev/null | grep $hard_drive | grep -v ${hard_drive}: -c)
    delete_counter=0
    while [ "$partition_count" -gt "0" ]; do
      delete_counter=$(( $delete_counter + 1 ))
      fdisk $1 &>/dev/null <<FDISK
d


w
FDISK
      partition_count=$(fdisk -l 2>/dev/null | grep $hard_drive | grep -v ${hard_drive}: -c)
      if [ "$delete_counter" -gt "1000" ]; then
        log " ...... Partitions Still Exist"
        fdisk -l &>>$CLIENT_LOG
        error "Could Not Delete MBR Partitions"			
      fi
    done
  fi
}

function change_computer_name()
{  
  local partition="$1"
  log " ** Changing Computer Name On $partition ** " "display"
  mkdir /mnt/ntfs		
  ntfs-3g -o force,rw,remove_hiberfile $partition /mnt/ntfs 2>> $CLIENT_LOG
  if [ "$?" != "0" ]; then
    log "Could Not Mount NTFS To Change Computer Name"
	return 1
  fi
  
  if [ -f "/mnt/ntfs/Windows/Panther/unattend.xml" ] || [ -f "/mnt/ntfs/Windows/panther/unattend.xml" ]; then
    log " ...... Found Answer File At /Windows/Panther/unattend.xml, Changing Computer Name" "display"
    perl -0777 -i -pe "s/(\<ComputerName\>).*(\<\/ComputerName\>)/\${1}$computer_name\${2}/si" /mnt/ntfs/Windows/Panther/unattend.xml 
  elif [ -f "/mnt/ntfs/Windows/System32/sysprep/Panther/unattend.xml" ]; then
    log " ...... Found Answer File At /Windows/System32/sysprep/Panther/unattend.xml, Changing Computer Name" "display"
    perl -0777 -i -pe "s/(\<ComputerName\>).*(\<\/ComputerName\>)/\${1}$computer_name\${2}/si" /mnt/ntfs/Windows/System32/sysprep/Panther/unattend.xml
  elif [ -f "/mnt/ntfs/Sysprep/sysprep.inf" ]; then
    log " ...... Found Answer File, Changing Host Name" "display"
    sed -i "s/^\s*ComputerName=.*$/ComputerName=$computer_name\r/I" /mnt/ntfs/Sysprep/sysprep.inf
  else
    log " ...... Could Not Find Answer File, Attempting Registry Change" "display"
	#Editing the registry is case sensitive, these are all the variations I have found so far.
    update_registry_key "/mnt/ntfs/Windows/System32/config/SYSTEM" "\ControlSet001\Services\Tcpip\Parameters\NV Hostname" "$computer_name"
    update_registry_key "/mnt/ntfs/Windows/System32/config/SYSTEM" "\ControlSet001\Control\ComputerName\ComputerName\ComputerName" "$computer_name"				
    update_registry_key "/mnt/ntfs/Windows/System32/config/SYSTEM" "\ControlSet001\Services\Tcpip\Parameters\Hostname" "$computer_name"
    update_registry_key "/mnt/ntfs/Windows/System32/config/SYSTEM" "\ControlSet001\Services\Tcpip\Parameters\HostName" "$computer_name"				
    update_registry_key "/mnt/ntfs/Windows/System32/config/SYSTEM" "\ControlSet001\Services\Tcpip\Parameters\NV HostName" "$computer_name"
    update_registry_key "/mnt/ntfs/Windows/System32/config/SYSTEM" "\ControlSet001\services\Tcpip\Parameters\NV Hostname" "$computer_name"					
    update_registry_key "/mnt/ntfs/WINDOWS/system32/config/system" "\ControlSet001\Services\Tcpip\Parameters\NV Hostname" "$computer_name"
    update_registry_key "/mnt/ntfs/WINDOWS/system32/config/system" "\ControlSet001\Control\ComputerName\ComputerName\ComputerName" "$computer_name"
  fi
  umount /mnt/ntfs	
}

#Function currently only supports Windows.
#Todo: Add linux support
function make_bootable()
{
  if [ "$standard_partition_type" = "legacy" ] || [ "$standard_partition_type" = "efi" ]; then
    partitions=$(lsblk -ipno KNAME | sort | grep "$hard_drive" | grep -vw "$hard_drive" | grep -v "boot" | grep -v "rpmb")
    for partition in $partitions; do
	  partition_prefix=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g'`
	  break
	done
	
	umount /mnt/ntfs
	if [ "$standard_partition_type" = "legacy" ]; then
	  log "Making system bootable - legacy"
	  mkfs.ntfs -f ${hard_drive}${partition_prefix}1 2>> $CLIENT_LOG
	  mkdir /mnt/bcd
	  mkdir /mnt/win
	  ntfs-3g -o force,rw,remove_hiberfile ${hard_drive}${partition_prefix}1 /mnt/bcd 2>> $CLIENT_LOG
	  ntfs-3g -o force,rw,remove_hiberfile ${hard_drive}${partition_prefix}2 /mnt/win 2>> $CLIENT_LOG
	  mkdir /mnt/bcd/Boot
	  if [ ! -d "/mnt/win/Windows/Boot/PCAT/" ]; then
	    log "Legacy boot files could not be found.  System will not be bootable."
		ls /mnt/win >> $CLIENT_LOG
		ls /mnt/win/Windows >> $CLIENT_LOG
		ls /mnt/win/Windows/Boot >> $CLIENT_LOG
	    ls /mnt/win/Windows/Boot/PCAT >> $CLIENT_LOG
		return 1
	  fi
	  cp -R /mnt/win/Windows/Boot/PCAT/* /mnt/bcd/Boot/ 2>> $CLIENT_LOG
	  cp /usr/share/bcd/legacy /mnt/bcd/Boot/BCD 2>> $CLIENT_LOG
	  cp /mnt/win/Windows/Boot/PCAT/bootmgr /mnt/bcd 2>> $CLIENT_LOG
	  cp /mnt/win/Windows/Boot/PCAT/bootnxt /mnt/bcd 2>> $CLIENT_LOG
	  
	  disk_signature=$(fdisk -l $hard_drive | grep -i "disk identifier:" | cut -d " " -f3)
	  updated_bcd=$($curlAuth -F diskSignature="$(echo -n "$disk_signature" | base64)" "${web}GetStandardLegacyBcd" $curlEnd)
	  echo $updated_bcd | base64 -d >/tmp/updatedbcd
	  
	  #log " ** Updated BCD Is ** "
	  #cat /tmp/updatedbcd >> $CLIENT_LOG
	  reged -I -C /mnt/bcd/Boot/BCD . /tmp/updatedbcd &>/dev/null
	  umount /mnt/bcd
	  umount /mnt/win
	  ms-sys -7 -f $hard_drive 2>> $CLIENT_LOG
	  ms-sys -n -f ${hard_drive}${partition_prefix}1	2>> $CLIENT_LOG
	else # standard efi
	  log "Making system bootable - efi"
	  mkfs.ntfs -f ${hard_drive}${partition_prefix}1 2>> $CLIENT_LOG
	  mkfs.fat -F 32 ${hard_drive}${partition_prefix}2 2>> $CLIENT_LOG
	  mkdir /mnt/bcd
	  mkdir /mnt/win
	  mount ${hard_drive}${partition_prefix}2 /mnt/bcd 2>> $CLIENT_LOG
	  ntfs-3g -o force,rw,remove_hiberfile ${hard_drive}${partition_prefix}4 /mnt/win 2>> $CLIENT_LOG
	  if [ ! -d "/mnt/win/Windows/Boot/EFI/" ]; then
	    log "EFI boot files could not be found.  System will not be bootable."
		ls /mnt/win >> $CLIENT_LOG
		ls /mnt/win/Windows >> $CLIENT_LOG
		ls /mnt/win/Windows/Boot >> $CLIENT_LOG
	    ls /mnt/win/Windows/Boot/EFI >> $CLIENT_LOG
		return 1
	  fi
	  mkdir -p /mnt/bcd/EFI/Microsoft/Boot
	  cp -R /mnt/win/Windows/Boot/EFI/* /mnt/bcd/EFI/Microsoft/Boot 2>> $CLIENT_LOG
	  cp /usr/share/bcd/efi /mnt/bcd/EFI/Microsoft/Boot/BCD 2>> $CLIENT_LOG
	  
	  disk_guid=$(gdisk -l $hard_drive | grep GUID | awk -F': ' '{print $2}')
	  recovery_guid=$(sgdisk $hard_drive -i1 | grep "unique GUID" | awk -F ' ' '{print $4}')
	  windows_guid=$(sgdisk $hard_drive -i4 | grep "unique GUID" | awk -F ' ' '{print $4}')
	  efi_guid=$(sgdisk $hard_drive -i2 | grep "unique GUID" | awk -F ' ' '{print $4}')
	  
	  log "disk_guid: $disk_guid"
	  log "recovery_guid: $recovery_guid"
	  log "windows_guid: $windows_guid"
	  log "efi_guid: $efi_guid"

	  updated_bcd=$($curlAuth -F diskGuid="$(echo -n "$disk_guid" | base64)" -F windowsGuid="$(echo -n "$windows_guid" | base64)" -F recoveryGuid="$(echo -n "$recovery_guid" | base64)" -F efiGuid="$(echo -n "$efi_guid" | base64)" "${web}GetStandardEfiBcd" $curlEnd)
	  echo $updated_bcd | base64 -d >/tmp/updatedbcd
	  #log " ** Updated BCD Is ** "
	  #cat /tmp/updatedbcd >> $CLIENT_LOG
	  reged -I -C /mnt/bcd/EFI/Microsoft/Boot/BCD . /tmp/updatedbcd &>/dev/null
	  umount /mnt/bcd
	  umount /mnt/win
	  ms-sys -7 -f $hard_drive
	  	  
	fi

  else
    if [ "$fix_bcd" != "true" ]; then
      log "BCD Update Has Been Skipped Via Image Profile"
      return 0
    fi
	  umount /mnt/ntfs 2>/dev/null
      log " ** Updating BCD ** " "display"
	mkdir /mnt/bootcheck
	mkdir /mnt/bcd
	mkdir /mnt/windows
	  
	#search through partitions to find boot and windows, or system and boot to be confusing
	local partitions=$(lsblk -ipno KNAME | sort | grep "$hard_drive" | grep -vw "$hard_drive" | grep -v "boot" | grep -v "rpmb")
    for partition in $partitions; do
	  local partition_prefix=`echo $partition | awk -F $hard_drive ' {print $2}' | sed 's/[0-9]*//g'`
	  local filesystem_type=`blkid -po udev $partition | grep FS_TYPE | awk -F'=' '{print $2}'`
	
      if [ "$filesystem_type" = "ntfs" ]; then
	    ntfs-3g -o force,rw,remove_hiberfile $partition /mnt/bootcheck 2>> $CLIENT_LOG
	  elif [ "$filesystem_type" = "vfat" ]; then
	    mount $partition /mnt/bootcheck 2>> $CLIENT_LOG
	  else
	    continue
	  fi
	
	  if [ -d "/mnt/bootcheck/Windows" ] || [ -d "/mnt/bootcheck/windows" ]; then
	    local windows_partition=$partition
		umount /mnt/bootcheck
	    ntfs-3g -o force,rw,remove_hiberfile $partition /mnt/windows 2>> $CLIENT_LOG
	  elif [ -f "/mnt/bootcheck/Boot/BCD" ] || [ -f "/mnt/bootcheck/EFI/Microsoft/Boot/BCD" ]; then
	    local boot_partition=$partition
		umount /mnt/bootcheck
		if [ "$filesystem_type" = "ntfs" ]; then
	      ntfs-3g -o force,rw,remove_hiberfile $partition /mnt/bcd 2>> $CLIENT_LOG
	    else
	      mount $partition /mnt/bcd 2>> $CLIENT_LOG
	    fi
	  fi
	
	  if [ -n "$windows_partition" ] && [ -n "$boot_partition" ]; then
	    break
	  fi
	   umount /mnt/bootcheck
	  done
	  
	  if [ -z "$windows_partition" ] && [ -z "$boot_partition" ]; then
	    log "Could not determine the system and boot partitions.  Computer may not boot."
		log "windows_partition: $windows_partition"
		log "boot_partition: $boot_partition"
		return 1
	  fi
	  
	  mount -t efivarfs none /sys/firmware/efi/efivars 2>>$CLIENT_LOG
	  efibootmgr -v 2>> $CLIENT_LOG
      if [ "$?" != "0" ]; then
        log "Legacy Boot Layout Selected"
	    boot_layout="legacy"
		if [ "$randomize_guids" = "true" ]; then
		  new_signature=$(uuidgen | cut -c -8)
		  log "new_signature: $new_signature"
		  fdisk $hard_drive <<EOF > /dev/null
x
i
0x${new_signature}
r
w
EOF
	    fi
		
		local partition_number=`echo $windows_partition | awk -F $hard_drive ' {print $2}' | sed 's/[^0-9]//g'`
		windows_partition_offset=$(parted -s $hard_drive unit b print all | grep " $partition_number " -m 1 | awk -F' ' '{print $2}' | sed 's/B//g')
		disk_signature=$(fdisk -l $hard_drive | grep -i "disk identifier:" | cut -d " " -f3)
		reged -x /mnt/bcd/Boot/BCD . Objects /tmp/regbcd >> /dev/null
        original_bcd=$(cat /tmp/regbcd | perl -pe 's/\\\r\n//' | sed 's/,  /,/g')
		updated_bcd=$($curlAuth -F bcd="$(echo -n "$original_bcd" | base64)" -F offsetBytes="$(echo -n "$windows_partition_offset" | base64)" -F diskSignature="$(echo -n "$disk_signature" | base64)" "${web}UpdateLegacyBcd" $curlEnd)
        echo $updated_bcd | base64 -d >>/tmp/updatedbcd
        #log " ** Updated BCD Is ** "
        #cat /tmp/updatedbcd >> $CLIENT_LOG
		
		#cp -R /mnt/windows/Windows/Boot/PCAT/* /mnt/bcd/Boot/ 2>> $CLIENT_LOG
	    #cp /mnt/windows/Windows/Boot/PCAT/bootmgr /mnt/bcd 2>> $CLIENT_LOG
	    #cp /mnt/windows/Windows/Boot/PCAT/bootnxt /mnt/bcd 2>> $CLIENT_LOG
	  
        reged -I -C /mnt/bcd/Boot/BCD . /tmp/updatedbcd &>/dev/null
		ms-sys -7 -f $hard_drive 2>> $CLIENT_LOG
	    ms-sys -n -f $boot_partition	2>> $CLIENT_LOG

	  else
	    log "Efi Boot Layout Selected"
	    boot_layout="efi"
		if [ "$randomize_guids" = "true" ]; then
		  sgdisk -G $hard_drive
		fi
		
		local windows_number=`echo $windows_partition | awk -F $hard_drive ' {print $2}' | sed 's/[^0-9]//g'`
		local recovery_number=$(parted -s $hard_drive print all | grep diag | head -1 | cut -d" " -f2)
	    disk_guid=$(gdisk -l $hard_drive | grep GUID | awk -F': ' '{print $2}')
	    recovery_guid=$(sgdisk $hard_drive -i$recovery_number | grep "unique GUID" | awk -F ' ' '{print $4}')
	    windows_guid=$(sgdisk $hard_drive -i$windows_number | grep "unique GUID" | awk -F ' ' '{print $4}')
	    reged -x /mnt/bcd/EFI/Microsoft/Boot/BCD . Objects /tmp/regbcd >> /dev/null
        original_bcd=$(cat /tmp/regbcd | perl -pe 's/\\\r\n//' | sed 's/,  /,/g')
	    updated_bcd=$($curlAuth -F bcd="$(echo -n "$original_bcd" | base64)" -F diskGuid="$(echo -n "$disk_guid" | base64)" -F windowsGuid="$(echo -n "$windows_guid" | base64)" -F recoveryGuid="$(echo -n "$recovery_guid" | base64)" "${web}UpdateEfiBcd" $curlEnd)
		
		log "disk_guid: $disk_guid"
	    log "recovery_guid: $recovery_guid"
	    log "windows_guid: $windows_guid"
	    
		echo $updated_bcd | base64 -d >>/tmp/updatedbcd
        #log " ** Updated BCD Is ** "
        #cat /tmp/updatedbcd >> $CLIENT_LOG
		
		#cp -R /mnt/windows/Windows/Boot/EFI/* /mnt/bcd/EFI/Microsoft/Boot 2>> $CLIENT_LOG
		reged -I -C /mnt/bcd/EFI/Microsoft/Boot/BCD . /tmp/updatedbcd &>/dev/null
		ms-sys -7 -f $hard_drive
		
      fi
	  
	  umount /mnt/windows
	  umount /mnt/bcd
	  
	  
  fi
 
}


function main()
{
  log_boot_args

  checkin
    
  mount_smb

  process_hard_drives
	
  checkout
}

main "$@"



